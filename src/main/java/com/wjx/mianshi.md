聊聊你的项目吧？

1。 首先我先谈一下们的团队分工：
    业务组：
    运营组：
    风控组：
    资金组：
    催收组：
    产品组：
    支付组：
    QA：
    数据组：

2. 我所处的组是业务组：
    负责我们团队的核心业务流程，登陆模块，用户模块，信息收集模块，授信模块，产品模块，进件模块，账单生成和还款模块。
    还参与一些其他的非核心模块的指导开发工作：比如保险模块,合同模块，电签模块等。
    项目采取微服务架构设计，采用业务模型，主链路模型和压力模型拆分业务将我们的业务拆分为了6个微服务。
    主要的工作有，产品需求评审，技术文档设计(包括数据库设计，业务模型设计)，代码开发，
    编写单元测试，编写数据监控脚本，代码review,代码上线，线上报警处理等。

3. 以最近的项目为例，以我们的业务为基础，对接新的流量渠道lazada，实现现金贷业务。接下来我按照开发流程来串联我们的项目，然后我再详细介绍一下我负责的模块：
    1. 首先，由产品分析需求，和对面产品对接，出需求文档。
    接下来我们会拉着产品，风控等相关方，先进行需求评审，我会从技术角度给出意见。接着我会开始编写技术文档，提供包括表结构设计，业务模型，rest风格的API。
然后我们会拉着QA同学进行技术文档评审答辩,并给出dead Line。接下来进入开发阶段，首先进行任务拆分与估时，然后指定任务开发人员，在代码开发+单元测试写完毕后，编写上线文档，
然后我们会发起内部Review,review通过后，就可以进入提测阶段，这个时候会处理QA提出的bug，并且开始编写一些监控脚本。
QA在测试通过之后，会发送测试报告，然后我会在版本上线时间进行代码和监控脚本的上线。
    2. 基本流程大概是这样，接下来我说一下我在其中的工作吧：
        1. 首先在需求设计阶段，我会从技术层面出发，给产品的需求设计指出其中的流程设计问题和其他的技术问题，并从高可用，高性能角度出发并给出更合理的系统实现方案。
        2. 接下来就是技术文档设计阶段，我会从高可用，高性能，数据安全性角度编写自己的技术文档，给出一个高可用，高性能并且逻辑闭环的设计方案，并进行设计方案评审答辩，
在这个评审阶段，我也会指出其他组员的技术或者逻辑问题，提出自己的建议。
        3. 在接下来就是任务拆分与分配阶段，我会根据业务逻辑，开发人员经验，模块分布等进行任务拆分与估时，建立相关sprint,再根据开发人员的能力指定对应人员进行开发。
        4. 然后就进入了代码编写阶段了， 我先说一下我们的主要业务场景，首先我们会提供用户信息上传，授信，进件，还款接口等需要提供给lazada.我们的目标是打造用户一次请求，快速放款的系统。
接下来说一下我们的订单状态，根据这个状态可以更好的把握我们的业务逻辑，分为Approving,Aprroved,Disbursing,disbursed,ongoing,completed,overdue,Baddebt。
我先说一下创建订单前的一些操作，我们会通过用户信息上传，授信，进件来收集用户信息，并且会开发相的数据源和feature暴露给风控，
风控引擎根据我们提供的feature和数据组提供的一些信息，运行设置好的风控规则，来对用户的贷款行为进行判断，风控结果一般会有三种，approved表示用户风险可控并给出相关的授信额度，rejected表示是风险用户并给出拒绝期,
returned打回表示用户资料不足，需要补充。我们在创建进件成功后会发给风控系统进行审核，风控引擎审核后会发送审核MQ,我们的系统接收到审核MQ后，如果是Approved则进入资金匹配阶段，调用funding资金组的接口后，funding会以MQ的形式来通知我们匹配结果。
如果匹配成功，则进入放款阶段，如果放款失败，则重试。放款成功后，会根据订单信息生成相应的账单，一般我们会将砍头息等前置费用生成第0期订单，然后根据期数生成N期账单。如果用户按期还款则对接支付，接收到支付MQ后，还款成功则进行账单更新。在此阶段用户可以进行展期申请，如果用户没有按时还款，则会进入进入逾期阶段。
我们后台对应的分布式逾期计算的定时任务，每天凌晨1点计算逾期信息，并更新账单数据。如果用户一直未还款，订单就会变更为baddebet。
    这是主要的业务逻辑，接下来我来说一下业务端的服务拆分情况吧，首先是底层基础服务 user-provider提供用户管理，juno提供图片存取管理服务，然后是具有公共逻辑的模块组成一个project pintar-partner, 其中的loan-api-provider对外提供api接口并处理主授信进件主逻辑，包括用户校验与参数签名，inner-service对内提供查询服务，listener-service由MQ驱动负责推动业务流程运转，boss-web提供后台管理功能。
    说完了的服务架构后，我在说一下任务分配的事，根据业务模块，将user-provider，boss-web分给另一个同事后，我主要负责pintar-partner核心模块的开发。
    接下来就是代码开发阶段了，首先进行主链路分析：用户信息上传->授信->进件->匹债->放款->账单->还款。

            1. 接下来是pojo层的模型建立，主要的表结构有授信表，进件表，三方渠道进件表，进件意向表,用户信息表等。

            2. 从用户维度将，用户来到我们app,最想的就是得到一笔贷款。所以我们先谈谈放款前的主业务吧，首先定义领域模型，进行领域边界划分：
                1. 用户信息领域：主要负责参数格式校验，用户信息收集，用户信息填充. 请求通过用户信息领域后会生成一个代表本次请求的ReqEnvData对象。
                2. 授信/进件模型: 入参ReqEnvData，负责业务逻辑相关完整性校验，风控预判断，授信/订单创建。
                3. 基于MQ的状态驱动模型：根据订单流转过程的MQ进行业务逻辑推动。
                4. 账单领域模型。
            3. 先谈谈最开始的用户信息领域吧，用户的信息由lazada提供，会从用户信息上传，授信，进件三个接口收集，不同接口的字段和校验规则大体相同，但不可避免又有区别。
并且需要支持用户信息的补充式上传校验。所以面临的问题是不同的接口，近似的参数，不同的校验，这个问题如何优雅的实现？
            授信进件前都需要进行用户的信息完整性校验，通过之后才可以授信/进件。
            进件则更加复杂，进件时如果用户没有授信，需要先保存贷款意向，进入授信流程，授信通过后系统自动进件。 授信/进件的时候我们还会调用风控团队的接口，进行风险评估。
            从java的面向对象思想结合java对象分层来分析，三个接口有很多重复的字段，都涉及用户信息领域，所以我们按照业务逻辑首先建立输入模型，即AO模型，
授信与进件接口都包含用户信息，所以构成了继承关系，即授信AO,进件AO都继承用户信息AO.
有了AO层和pojo层，接着我采用DDD领域模型思想，在AO层建立对应的转换逻辑，即可实现模型对象的快速转换，并在各级AO定义自身填充方法，从而支持多次补充式校验。
针对相同AO，不同校验规则的场景，我们采用java.validator包的group功能，将校验规则分组，并对自定义注解来实现部分特殊的校验，尽量将参数的格式校验提前，从而剥离对主业务逻辑的影响，达到解藕的目的。
在用户领域模型之后，请求所带的用户信息，通过校验后，经过数据库数据填充，然后保存最新用户信息，并将用户最新信息输出，用于业务请求环境信息构造。
发现了没有，这几个接口的信息领域模型逻辑基本一致，所以特别使用采用模版方法进行设计，来提高代码的可阅读性与可扩展性。
           4. 然后进入授信/进件模型，从入参AO模型来说，他们都继承用户信息AO模型。从业务角度分析，授信与进件流程类似，并且进件包含授信流程，因此应该将公共逻辑抽出来，封装成抽象类，比如参数完整性校验和授信流程。
所以授信实现类比较简单，继承抽象类，并实现其定义的一些接口即可，如标识业务类型的接口等。
而进件实现类也继承抽象类，但逻辑则比较复杂，首先请求风控，如果风控告诉我们需要授信，则走抽象类的授信流程，并实现自己的特殊逻辑，比如保存贷款意向。 
 如果风控告诉我们需要进件，则进入进件逻辑。在这个过程中，我们采用redission来作为分布式锁，排除并发的问题。
           5. 接下来进入MQ驱动相关模型：首先是监控审核结果的MQ,当审核成功后，调用funding发进行资金匹配，
              接收到资金匹配成功MQ后，调用支付端进行放款，
              接收到放款成功的MQ后，生成bill账单。
              基于AOP，对订单状态的更新方法进行切面，订单状态的更新会发送更新MQ
              订单相应的合同会在收到订单ONGOING状态时进行生成。至此，用户放款成功。   
    
    
    
    
